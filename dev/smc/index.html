<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using SMC · SMC.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SMC.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Using SMC</a><ul class="internal"><li><a class="toctext" href="#SMC-Main-Function-1">SMC Main Function</a></li></ul></li><li><a class="toctext" href="../helpers/">Helper Functions</a></li><li><a class="toctext" href="../license/">License</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Using SMC</a></li></ul><a class="edit-page" href="https://github.com/FRBNY-DSGE/SMC.jl/blob/master/docs/src/smc.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Using SMC</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="SMC-Main-Function-1" href="#SMC-Main-Function-1">SMC Main Function</a></h2><p>You can use SMC to estimate any Bayesian model. This requires (1) parameters and their associated prior distributions (2) data (3) a likliehood function. These three ingredients are the only inputs into the smc driver.</p><p><code>smc(loglikelihood::Function, parameters::ParameterVector, data::Matrix)</code> function.</p><p>Let&#39;s look at an example. First, we&#39;ll make a model. We need the <a href="https://frbny-dsge.github.io/ModelConstructors.jl">ModelConstructors</a> package to do that.</p><pre><code class="language-julia">using ModelConstructors
ols_model = GenericModel()</code></pre><pre><code class="language-none">Model 
no. parameters:             0
description:
 A generic model: You can put parameters, states, shocks, observables, pseudo-observables, spec, subpsec, settings inside of me
</code></pre><p>Next, assign our intercept and coefficient parameters to the model.</p><pre><code class="language-">reg &lt;= parameter(:α1, 0., (-1e5, 1e5), (-1e5, 1e5), Untransformed(), Normal(0, 10), fixed = false)
reg &lt;= parameter(:β1, 0., (-1e5, 1e5), (-1e5, 1e5), Untransformed(), Normal(0, 10), fixed = false)</code></pre><p>The first argument is the name of the parameter, the second is its initial value, the third and fourther are bounds on the parameter (they should always be the same). If the sampler draws a value outside of these bounds, it&#39;ll try again. The fifth argument is whether you would like to perform a transformation on the parameter when using it (ignore this for now–it&#39;s for more advanced users). The sixth argument is the prior, <span>$N(0, 10)$</span>, and last argument says the parameters aren&#39;t fixed parameters (i.e. we&#39;re trying to estimate them!)</p><p>We&#39;ll make some artifical data to test our model</p><pre><code class="language-julia">β = 1.
α = 1.
y = β*X + α</code></pre><pre><code class="language-none">100-element Array{Float64,1}:
 1.7982768624815304
 1.8706763462995302
 1.6611300317024342
 1.279692124647822 
 1.1163322701458438
 1.9220390217503973
 1.2144784620817473
 1.3498425765900104
 1.8941287983018167
 1.097760213045384 
 ⋮                 
 1.0266587997750434
 1.447363286258172 
 1.2938889744335087
 1.7418306223962174
 1.5805577525308265
 1.295438513730291 
 1.055235600862271 
 1.469619166037717 
 1.7100962913432323</code></pre><p>We need a log-likelihood function! Note that it&#39;s important you define a log-likelihood function rather than a likelihood function.</p><pre><code class="language-julia">function likelihood_fnct(p, d)
    α = p[1]
    β = p[2]
    Σ = 1
    det_Σ = det(Σ)
    inv_Σ = inv(Σ)
    term1 = -N / 2 * log(2 * π) - 1 /2 * log(det_Σ)
    logprob = 0.
    errors = d[:, 1] .- α .- β .* d[:, 2]
    for t in 1:size(d,1)
        logprob += term1 - 1/2 * dot(errors, inv_Σ * errors)
    end
    return logprob
end</code></pre><pre><code class="language-none">likelihood_fnct (generic function with 1 method)</code></pre><p>And that&#39;s it! Now let&#39;s run SMC.</p><pre><code class="language-">smc(likelihood_fnct, reg.parameters, data, n_parts = 10, use_fixed_schedule = false, tempering_target = 0.97)</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SMC.smc-Union{Tuple{U}, Tuple{S}, Tuple{Function,Array{AbstractParameter{U},1},Array{S,2}}} where U&lt;:Number where S&lt;:AbstractFloat" href="#SMC.smc-Union{Tuple{U}, Tuple{S}, Tuple{Function,Array{AbstractParameter{U},1},Array{S,2}}} where U&lt;:Number where S&lt;:AbstractFloat"><code>SMC.smc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">function smc(loglikelihood::Function, parameters::ParameterVector{U}, data::Matrix{S};
             kwargs...) where {S&lt;:AbstractFloat, U&lt;:Number}</code></pre><p><strong>Arguments:</strong></p><ul><li><code>loglikelihood::Function</code>: Log-likelihood function of model being estimated. Takes <code>parameters</code>   and <code>data</code> as arguments.</li><li><code>parameters::ParameterVector{U}</code>: Model parameter vector, which stores parameter values,   prior dists, and bounds.</li><li><code>data</code>: A matrix or dataframe containing the time series of the observables used in   the calculation of the posterior/loglikelihood</li><li><code>old_data</code>: A matrix containing the time series of observables of previous data   (with <code>data</code> being the new data) for the purposes of a time tempered estimation   (that is, using the posterior draws from a previous estimation as the initial set   of draws for an estimation with new data)</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>verbose::Symbol</code>: Desired frequency of function progress messages printed to standard out.</li></ul><pre><code class="language-none">- `:none`: No status updates will be reported.
- `:low`: Status updates for SMC initialization and recursion will be included.
- `:high`: Status updates for every iteration of SMC is output, which includes
the mean and standard deviation of each parameter draw after each iteration,
as well as calculated acceptance rate, ESS, and number of times resampled.</code></pre><ul><li><p><code>parallel::Bool</code>: Flag for running algorithm in parallel.</p></li><li><p><code>n_parts::Int</code>: Number of particles.</p></li><li><p><code>n_blocks::Int</code>: Number of parameter blocks in mutation step.</p></li><li><p><code>n_mh_steps::Int</code>: Number of Metropolis Hastings steps to attempt during the mutation step.</p></li><li><p><code>λ::S</code>: The &#39;bending coefficient&#39; λ in Φ(n) = (n/N(Φ))^λ</p></li><li><p><code>n_Φ::Int</code>: Number of stages in the tempering schedule.</p></li><li><p><code>resampling_method::Symbol</code>: Which resampling method to use.</p><ul><li><code>:systematic</code>: Will use sytematic resampling.</li><li><code>:multinomial</code>: Will use multinomial resampling.</li><li><code>:polyalgo</code>: Samples using a polyalgorithm.</li></ul></li><li><p><code>threshold_ratio::S</code>: Threshold s.t. particles will be resampled when the population   drops below threshold * N.</p></li><li><p><code>c::S</code>: Scaling factor for covariance of the particles. Controls size of steps in mutation step.</p></li><li><p><code>α::S</code>: The mixture proportion for the mutation step&#39;s proposal distribution.</p></li><li><p><code>target::S</code>: The initial target acceptance rate for new particles during mutation.</p></li><li><p><code>use_chand_recursion::Bool</code>: Flag for using Chandrasekhar Recursions in Kalman filter.</p></li><li><p><code>use_fixed_schedule::Bool</code>: Flag for whether or not to use a fixed tempering (ϕ) schedule.</p></li><li><p><code>tempering_target::S</code>: Coefficient of the sample size metric to be targeted when solving   for an endogenous ϕ.</p></li><li><p><code>old_data::Matrix{S}</code>: data from vintage of last SMC estimation.</p></li><li><p><code>old_cloud::Cloud</code>: associated cloud borne of old data in previous SMC estimation.</p></li><li><p><code>old_vintage::String</code>: String for vintage date of old data</p></li><li><p><code>smc_iteration::Int</code>: The iteration index for the number of times SMC has been run on the    same data vintage. Primarily for numerical accuracy/testing purposes.</p></li><li><p><code>run_test::Bool</code>: Flag for when testing accuracy of program</p></li><li><p><code>filestring_addl::Vector{String}</code>: Additional file string extension for loading old cloud.</p></li><li><p><code>continue_intermediate::Bool</code>: Flag to indicate whether one is continuing SMC from an   intermediate stage.</p></li><li><p><code>intermediate_stage_start::Int</code>: Intermediate stage at which one wishes to begin the estimation.</p></li><li><p><code>save_intermediate::Bool</code>: Flag for whether one wants to save intermediate Cloud objects</p></li><li><p><code>intermediate_stage_increment::Int</code>: Save Clouds at every increment   (1 = each stage, 10 = every 10th stage, etc.)</p></li></ul><p><strong>Outputs</strong></p><ul><li><code>cloud</code>: The Cloud object containing all of the information about the   parameter values from the sample, their respective log-likelihoods, the ESS   schedule, tempering schedule etc., which is saved in the saveroot.</li></ul><p><strong>Overview</strong></p><p>Sequential Monte Carlo can be used in lieu of Random Walk Metropolis Hastings to     generate parameter samples from high-dimensional parameter spaces using     sequentially constructed proposal densities to be used in iterative importance     sampling.</p><p>This implementation is based on Edward Herbst and Frank Schorfheide&#39;s 2014 paper     &#39;Sequential Monte Carlo Sampling for DSGE Models&#39; and the code accompanying their     book &#39;Bayesian Estimation of DSGE Models&#39;.</p><p>SMC is broken up into three main steps:</p><ul><li><code>Correction</code>: Reweight the particles from stage n-1 by defining incremental weights,   which gradually &quot;temper in&quot; the loglikelihood function p(Y|θ)^(ϕ<em>n - ϕ</em>n-1) into the   normalized particle weights.</li><li><code>Selection</code>: Resample the particles if the distribution of particles begins to   degenerate, according to a tolerance level for the ESS.</li><li><code>Mutation</code>: Propagate particles {θ(i), W(n)} via N(MH) steps of a Metropolis   Hastings algorithm.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/FRBNY-DSGE/SMC.jl/blob/0b2428906ce1ebabf80ca505290cfe556c630b08/src/smc_main.jl#L1-L90">source</a></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../helpers/"><span class="direction">Next</span><span class="title">Helper Functions</span></a></footer></article></body></html>
